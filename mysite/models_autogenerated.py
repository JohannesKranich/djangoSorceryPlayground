"""Autogenerated SQLAlchemy models based on OpenAlchemy models."""
# pylint: disable=no-member,super-init-not-called,unused-argument

import typing

import sqlalchemy
from sqlalchemy import orm

from open_alchemy import models

Base = models.Base  # type: ignore


class _EmployeeDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str
    division: str
    salary: float


class EmployeeDict(_EmployeeDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int


class TEmployee(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Person that works for a company.

    Attrs:
        id: Unique identifier for the employee.
        name: The name of the employee.
        division: The part of the company the employee works in.
        salary: The amount of money the employee is paid.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    name: 'sqlalchemy.Column[str]'
    division: 'sqlalchemy.Column[str]'
    salary: 'sqlalchemy.Column[float]'

    def __init__(self, name: str, division: str, salary: float, id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: Unique identifier for the employee.
            name: The name of the employee.
            division: The part of the company the employee works in.
            salary: The amount of money the employee is paid.

        """
        ...

    @classmethod
    def from_dict(cls, name: str, division: str, salary: float, id: typing.Optional[int] = None) -> "TEmployee":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: Unique identifier for the employee.
            name: The name of the employee.
            division: The part of the company the employee works in.
            salary: The amount of money the employee is paid.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TEmployee":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> EmployeeDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Employee: typing.Type[TEmployee] = models.Employee  # type: ignore


class _TaskDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    title: str


class TaskDict(_TaskDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int
    description: typing.Optional[str]
    employees: typing.Sequence["EmployeeDict"]


class TTask(typing.Protocol):
    """
    SQLAlchemy model protocol.

    A task that can be assigned to employees.

    Attrs:
        id: Unique identifier for the task.
        title: The title of the task.
        description: The description of the task.
        employees: List of employees associated with the task.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[int]'
    title: 'sqlalchemy.Column[str]'
    description: 'sqlalchemy.Column[typing.Optional[str]]'
    employees: 'sqlalchemy.Column[typing.Sequence["TEmployee"]]'

    def __init__(self, title: str, id: typing.Optional[int] = None, description: typing.Optional[str] = None, employees: typing.Optional[typing.Sequence["TEmployee"]] = None) -> None:
        """
        Construct.

        Args:
            id: Unique identifier for the task.
            title: The title of the task.
            description: The description of the task.
            employees: List of employees associated with the task.

        """
        ...

    @classmethod
    def from_dict(cls, title: str, id: typing.Optional[int] = None, description: typing.Optional[str] = None, employees: typing.Optional[typing.Sequence["EmployeeDict"]] = None) -> "TTask":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: Unique identifier for the task.
            title: The title of the task.
            description: The description of the task.
            employees: List of employees associated with the task.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TTask":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> TaskDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Task: typing.Type[TTask] = models.Task  # type: ignore


class EmployeeTaskDict(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    employee_id: int
    task_id: int


class TEmployeeTask(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        employee_id: The employee_id of the EmployeeTask.
        task_id: The task_id of the EmployeeTask.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    employee_id: 'sqlalchemy.Column[int]'
    task_id: 'sqlalchemy.Column[int]'

    def __init__(self, employee_id: int, task_id: int) -> None:
        """
        Construct.

        Args:
            employee_id: The employee_id of the EmployeeTask.
            task_id: The task_id of the EmployeeTask.

        """
        ...

    @classmethod
    def from_dict(cls, employee_id: int, task_id: int) -> "TEmployeeTask":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            employee_id: The employee_id of the EmployeeTask.
            task_id: The task_id of the EmployeeTask.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TEmployeeTask":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> EmployeeTaskDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


EmployeeTask: typing.Type[TEmployeeTask] = models.EmployeeTask  # type: ignore
